{\rtf1\ansi\ansicpg936\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 Times-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww19260\viewh11700\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs36 \cf0 \expnd0\expndtw0\kerning0
In this experiment, I tested three methods using the Random Forest classifier.\
\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 The first is 
\f1\b patch-level classification
\f0\b0 , where a sliding window extracts fixed-size patches, each labeled by its center pixel. To handle class imbalance, I kept all positive samples and randomly sampled negatives. This method achieved over 95% accuracy and an IoU of 0.1304. However, predictions remain at the patch level.\
The second is 
\f1\b patch-to-pixel reconstruction
\f0\b0 , where predicted center pixels are mapped back to their image positions. This gives a sparse pixel-level output for visual inspection, but due to many unlabeled pixels, the IoU drops by more than 400 times, showing limited boundary detection.\
The final method I used is 
\f1\b Pixel-level Feature-based Classification
\f0\b0 . Instead of using patches, I directly classify each pixel by extracting a 17-dimensional feature vector, including spectral values, NDVI, local statistics, and coordinates.\
To handle class imbalance, I used balanced class weights and tested different tree counts from 10 to 50. I chose 50 trees as it gave slightly better performance across all metrics. I also try thresholds from 0.5 to 0.95 and selected 0.748 for the best trade-off between precision and recall.\
This approach produced a dense, full-resolution segmentation map, achieving over 96% accuracy and 0.1916 IoU\'97making it the best-performing and the final method I adopted.\
}